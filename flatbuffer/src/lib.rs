#![allow(warnings)]
// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_GLOBAL_ID_TYPE: i8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_GLOBAL_ID_TYPE: i8 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GLOBAL_ID_TYPE: [GlobalIdType; 3] = [
    GlobalIdType::SceneRoot,
    GlobalIdType::NodeID,
    GlobalIdType::ObjectIndex,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GlobalIdType(pub i8);
#[allow(non_upper_case_globals)]
impl GlobalIdType {
    pub const SceneRoot: Self = Self(0);
    pub const NodeID: Self = Self(1);
    pub const ObjectIndex: Self = Self(2);

    pub const ENUM_MIN: i8 = 0;
    pub const ENUM_MAX: i8 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::SceneRoot, Self::NodeID, Self::ObjectIndex];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::SceneRoot => Some("SceneRoot"),
            Self::NodeID => Some("NodeID"),
            Self::ObjectIndex => Some("ObjectIndex"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for GlobalIdType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for GlobalIdType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for GlobalIdType {
    type Output = GlobalIdType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GlobalIdType {
    type Scalar = i8;
    #[inline]
    fn to_little_endian(self) -> i8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i8) -> Self {
        let b = i8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for GlobalIdType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for GlobalIdType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_IMAGE_DATA: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_IMAGE_DATA: u8 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_IMAGE_DATA: [ImageData; 4] = [
    ImageData::NONE,
    ImageData::ImageName,
    ImageData::RGBA,
    ImageData::Color,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ImageData(pub u8);
#[allow(non_upper_case_globals)]
impl ImageData {
    pub const NONE: Self = Self(0);
    pub const ImageName: Self = Self(1);
    pub const RGBA: Self = Self(2);
    pub const Color: Self = Self(3);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 3;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::NONE, Self::ImageName, Self::RGBA, Self::Color];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::ImageName => Some("ImageName"),
            Self::RGBA => Some("RGBA"),
            Self::Color => Some("Color"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for ImageData {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for ImageData {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for ImageData {
    type Output = ImageData;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ImageData {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for ImageData {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for ImageData {}
pub struct ImageDataUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_INTERPOLATION_TYPES: i8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_INTERPOLATION_TYPES: i8 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_INTERPOLATION_TYPES: [InterpolationTypes; 4] = [
    InterpolationTypes::None,
    InterpolationTypes::Step,
    InterpolationTypes::Linear,
    InterpolationTypes::Cubic,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct InterpolationTypes(pub i8);
#[allow(non_upper_case_globals)]
impl InterpolationTypes {
    pub const None: Self = Self(0);
    pub const Step: Self = Self(1);
    pub const Linear: Self = Self(2);
    pub const Cubic: Self = Self(3);

    pub const ENUM_MIN: i8 = 0;
    pub const ENUM_MAX: i8 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::None, Self::Step, Self::Linear, Self::Cubic];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::None => Some("None"),
            Self::Step => Some("Step"),
            Self::Linear => Some("Linear"),
            Self::Cubic => Some("Cubic"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for InterpolationTypes {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for InterpolationTypes {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for InterpolationTypes {
    type Output = InterpolationTypes;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for InterpolationTypes {
    type Scalar = i8;
    #[inline]
    fn to_little_endian(self) -> i8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i8) -> Self {
        let b = i8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for InterpolationTypes {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for InterpolationTypes {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ANIMATION_TARGET_TYPES: i16 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ANIMATION_TARGET_TYPES: i16 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ANIMATION_TARGET_TYPES: [AnimationTargetTypes; 2] =
    [AnimationTargetTypes::Object, AnimationTargetTypes::Bone];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AnimationTargetTypes(pub i16);
#[allow(non_upper_case_globals)]
impl AnimationTargetTypes {
    pub const Object: Self = Self(0);
    pub const Bone: Self = Self(1);

    pub const ENUM_MIN: i16 = 0;
    pub const ENUM_MAX: i16 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::Object, Self::Bone];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Object => Some("Object"),
            Self::Bone => Some("Bone"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for AnimationTargetTypes {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for AnimationTargetTypes {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i16>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for AnimationTargetTypes {
    type Output = AnimationTargetTypes;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i16>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for AnimationTargetTypes {
    type Scalar = i16;
    #[inline]
    fn to_little_endian(self) -> i16 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i16) -> Self {
        let b = i16::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for AnimationTargetTypes {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i16::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for AnimationTargetTypes {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_OBJECT: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_OBJECT: u8 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_OBJECT: [Object; 3] = [Object::NONE, Object::Mesh, Object::Empties];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Object(pub u8);
#[allow(non_upper_case_globals)]
impl Object {
    pub const NONE: Self = Self(0);
    pub const Mesh: Self = Self(1);
    pub const Empties: Self = Self(2);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::Mesh, Self::Empties];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::Mesh => Some("Mesh"),
            Self::Empties => Some("Empties"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for Object {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for Object {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for Object {
    type Output = Object;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Object {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for Object {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Object {}
pub struct ObjectUnionTableOffset {}

// struct Vector3, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Vector3(pub [u8; 12]);
impl Default for Vector3 {
    fn default() -> Self {
        Self([0; 12])
    }
}
impl core::fmt::Debug for Vector3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Vector3")
            .field("x", &self.x())
            .field("y", &self.y())
            .field("z", &self.z())
            .finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Vector3 {}
impl<'a> flatbuffers::Follow<'a> for Vector3 {
    type Inner = &'a Vector3;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a Vector3>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a Vector3 {
    type Inner = &'a Vector3;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<Vector3>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for Vector3 {
    type Output = Vector3;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(
            self as *const Vector3 as *const u8,
            <Self as flatbuffers::Push>::size(),
        );
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> flatbuffers::PushAlignment {
        flatbuffers::PushAlignment::new(4)
    }
}

impl<'a> flatbuffers::Verifiable for Vector3 {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.in_buffer::<Self>(pos)
    }
}

impl<'a> Vector3 {
    #[allow(clippy::too_many_arguments)]
    pub fn new(x: f32, y: f32, z: f32) -> Self {
        let mut s = Self([0; 12]);
        s.set_x(x);
        s.set_y(y);
        s.set_z(z);
        s
    }

    pub fn x(&self) -> f32 {
        let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[0..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_x(&mut self, x: f32) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[0..].as_mut_ptr(),
                core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn y(&self) -> f32 {
        let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[4..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_y(&mut self, x: f32) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[4..].as_mut_ptr(),
                core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn z(&self) -> f32 {
        let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[8..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_z(&mut self, x: f32) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[8..].as_mut_ptr(),
                core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
            );
        }
    }
}

// struct Vector4, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Vector4(pub [u8; 16]);
impl Default for Vector4 {
    fn default() -> Self {
        Self([0; 16])
    }
}
impl core::fmt::Debug for Vector4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Vector4")
            .field("x", &self.x())
            .field("y", &self.y())
            .field("z", &self.z())
            .field("w", &self.w())
            .finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Vector4 {}
impl<'a> flatbuffers::Follow<'a> for Vector4 {
    type Inner = &'a Vector4;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a Vector4>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a Vector4 {
    type Inner = &'a Vector4;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<Vector4>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for Vector4 {
    type Output = Vector4;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(
            self as *const Vector4 as *const u8,
            <Self as flatbuffers::Push>::size(),
        );
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> flatbuffers::PushAlignment {
        flatbuffers::PushAlignment::new(4)
    }
}

impl<'a> flatbuffers::Verifiable for Vector4 {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.in_buffer::<Self>(pos)
    }
}

impl<'a> Vector4 {
    #[allow(clippy::too_many_arguments)]
    pub fn new(x: f32, y: f32, z: f32, w: f32) -> Self {
        let mut s = Self([0; 16]);
        s.set_x(x);
        s.set_y(y);
        s.set_z(z);
        s.set_w(w);
        s
    }

    pub fn x(&self) -> f32 {
        let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[0..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_x(&mut self, x: f32) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[0..].as_mut_ptr(),
                core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn y(&self) -> f32 {
        let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[4..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_y(&mut self, x: f32) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[4..].as_mut_ptr(),
                core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn z(&self) -> f32 {
        let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[8..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_z(&mut self, x: f32) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[8..].as_mut_ptr(),
                core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn w(&self) -> f32 {
        let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[12..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_w(&mut self, x: f32) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[12..].as_mut_ptr(),
                core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
            );
        }
    }
}

// struct Transform, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Transform(pub [u8; 40]);
impl Default for Transform {
    fn default() -> Self {
        Self([0; 40])
    }
}
impl core::fmt::Debug for Transform {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Transform")
            .field("translation", &self.translation())
            .field("rotation", &self.rotation())
            .field("scale", &self.scale())
            .finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Transform {}
impl<'a> flatbuffers::Follow<'a> for Transform {
    type Inner = &'a Transform;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a Transform>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a Transform {
    type Inner = &'a Transform;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<Transform>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for Transform {
    type Output = Transform;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(
            self as *const Transform as *const u8,
            <Self as flatbuffers::Push>::size(),
        );
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> flatbuffers::PushAlignment {
        flatbuffers::PushAlignment::new(4)
    }
}

impl<'a> flatbuffers::Verifiable for Transform {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.in_buffer::<Self>(pos)
    }
}

impl<'a> Transform {
    #[allow(clippy::too_many_arguments)]
    pub fn new(translation: &Vector3, rotation: &Vector4, scale: &Vector3) -> Self {
        let mut s = Self([0; 40]);
        s.set_translation(translation);
        s.set_rotation(rotation);
        s.set_scale(scale);
        s
    }

    pub fn translation(&self) -> &Vector3 {
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid struct in this slot
        unsafe { &*(self.0[0..].as_ptr() as *const Vector3) }
    }

    #[allow(clippy::identity_op)]
    pub fn set_translation(&mut self, x: &Vector3) {
        self.0[0..0 + 12].copy_from_slice(&x.0)
    }

    pub fn rotation(&self) -> &Vector4 {
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid struct in this slot
        unsafe { &*(self.0[12..].as_ptr() as *const Vector4) }
    }

    #[allow(clippy::identity_op)]
    pub fn set_rotation(&mut self, x: &Vector4) {
        self.0[12..12 + 16].copy_from_slice(&x.0)
    }

    pub fn scale(&self) -> &Vector3 {
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid struct in this slot
        unsafe { &*(self.0[28..].as_ptr() as *const Vector3) }
    }

    #[allow(clippy::identity_op)]
    pub fn set_scale(&mut self, x: &Vector3) {
        self.0[28..28 + 12].copy_from_slice(&x.0)
    }
}

// struct RGBAColor, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct RGBAColor(pub [u8; 16]);
impl Default for RGBAColor {
    fn default() -> Self {
        Self([0; 16])
    }
}
impl core::fmt::Debug for RGBAColor {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RGBAColor")
            .field("rgba", &self.rgba())
            .finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for RGBAColor {}
impl<'a> flatbuffers::Follow<'a> for RGBAColor {
    type Inner = &'a RGBAColor;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a RGBAColor>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a RGBAColor {
    type Inner = &'a RGBAColor;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<RGBAColor>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for RGBAColor {
    type Output = RGBAColor;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(
            self as *const RGBAColor as *const u8,
            <Self as flatbuffers::Push>::size(),
        );
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> flatbuffers::PushAlignment {
        flatbuffers::PushAlignment::new(4)
    }
}

impl<'a> flatbuffers::Verifiable for RGBAColor {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.in_buffer::<Self>(pos)
    }
}

impl<'a> RGBAColor {
    #[allow(clippy::too_many_arguments)]
    pub fn new(rgba: &[f32; 4]) -> Self {
        let mut s = Self([0; 16]);
        s.set_rgba(rgba);
        s
    }

    pub fn rgba(&'a self) -> flatbuffers::Array<'a, f32, 4> {
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid array in this slot
        unsafe { flatbuffers::Array::follow(&self.0, 0) }
    }

    pub fn set_rgba(&mut self, items: &[f32; 4]) {
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid array in this slot
        unsafe { flatbuffers::emplace_scalar_array(&mut self.0, 0, items) };
    }
}

// struct Matrix4, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Matrix4(pub [u8; 64]);
impl Default for Matrix4 {
    fn default() -> Self {
        Self([0; 64])
    }
}
impl core::fmt::Debug for Matrix4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Matrix4").field("mat", &self.mat()).finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Matrix4 {}
impl<'a> flatbuffers::Follow<'a> for Matrix4 {
    type Inner = &'a Matrix4;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a Matrix4>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a Matrix4 {
    type Inner = &'a Matrix4;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<Matrix4>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for Matrix4 {
    type Output = Matrix4;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(
            self as *const Matrix4 as *const u8,
            <Self as flatbuffers::Push>::size(),
        );
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> flatbuffers::PushAlignment {
        flatbuffers::PushAlignment::new(4)
    }
}

impl<'a> flatbuffers::Verifiable for Matrix4 {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.in_buffer::<Self>(pos)
    }
}

impl<'a> Matrix4 {
    #[allow(clippy::too_many_arguments)]
    pub fn new(mat: &[f32; 16]) -> Self {
        let mut s = Self([0; 64]);
        s.set_mat(mat);
        s
    }

    pub fn mat(&'a self) -> flatbuffers::Array<'a, f32, 16> {
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid array in this slot
        unsafe { flatbuffers::Array::follow(&self.0, 0) }
    }

    pub fn set_mat(&mut self, items: &[f32; 16]) {
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid array in this slot
        unsafe { flatbuffers::emplace_scalar_array(&mut self.0, 0, items) };
    }
}

// struct GlobalNodeIdentifier, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct GlobalNodeIdentifier(pub [u8; 16]);
impl Default for GlobalNodeIdentifier {
    fn default() -> Self {
        Self([0; 16])
    }
}
impl core::fmt::Debug for GlobalNodeIdentifier {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GlobalNodeIdentifier")
            .field("type_", &self.type_())
            .field("id", &self.id())
            .finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for GlobalNodeIdentifier {}
impl<'a> flatbuffers::Follow<'a> for GlobalNodeIdentifier {
    type Inner = &'a GlobalNodeIdentifier;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a GlobalNodeIdentifier>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a GlobalNodeIdentifier {
    type Inner = &'a GlobalNodeIdentifier;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<GlobalNodeIdentifier>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for GlobalNodeIdentifier {
    type Output = GlobalNodeIdentifier;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(
            self as *const GlobalNodeIdentifier as *const u8,
            <Self as flatbuffers::Push>::size(),
        );
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> flatbuffers::PushAlignment {
        flatbuffers::PushAlignment::new(8)
    }
}

impl<'a> flatbuffers::Verifiable for GlobalNodeIdentifier {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.in_buffer::<Self>(pos)
    }
}

impl<'a> GlobalNodeIdentifier {
    #[allow(clippy::too_many_arguments)]
    pub fn new(type_: GlobalIdType, id: u64) -> Self {
        let mut s = Self([0; 16]);
        s.set_type_(type_);
        s.set_id(id);
        s
    }

    pub fn type_(&self) -> GlobalIdType {
        let mut mem = core::mem::MaybeUninit::<<GlobalIdType as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[0..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<GlobalIdType as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_type_(&mut self, x: GlobalIdType) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[0..].as_mut_ptr(),
                core::mem::size_of::<<GlobalIdType as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn id(&self) -> u64 {
        let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[8..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_id(&mut self, x: u64) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[8..].as_mut_ptr(),
                core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
            );
        }
    }
}

// struct InterpolationTargets, aligned to 1
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct InterpolationTargets(pub [u8; 4]);
impl Default for InterpolationTargets {
    fn default() -> Self {
        Self([0; 4])
    }
}
impl core::fmt::Debug for InterpolationTargets {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("InterpolationTargets")
            .field("translation", &self.translation())
            .field("rotation", &self.rotation())
            .field("scale", &self.scale())
            .field("weights", &self.weights())
            .finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for InterpolationTargets {}
impl<'a> flatbuffers::Follow<'a> for InterpolationTargets {
    type Inner = &'a InterpolationTargets;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a InterpolationTargets>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a InterpolationTargets {
    type Inner = &'a InterpolationTargets;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<InterpolationTargets>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for InterpolationTargets {
    type Output = InterpolationTargets;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(
            self as *const InterpolationTargets as *const u8,
            <Self as flatbuffers::Push>::size(),
        );
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> flatbuffers::PushAlignment {
        flatbuffers::PushAlignment::new(1)
    }
}

impl<'a> flatbuffers::Verifiable for InterpolationTargets {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.in_buffer::<Self>(pos)
    }
}

impl<'a> InterpolationTargets {
    #[allow(clippy::too_many_arguments)]
    pub fn new(
        translation: InterpolationTypes,
        rotation: InterpolationTypes,
        scale: InterpolationTypes,
        weights: InterpolationTypes,
    ) -> Self {
        let mut s = Self([0; 4]);
        s.set_translation(translation);
        s.set_rotation(rotation);
        s.set_scale(scale);
        s.set_weights(weights);
        s
    }

    pub fn translation(&self) -> InterpolationTypes {
        let mut mem =
            core::mem::MaybeUninit::<<InterpolationTypes as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[0..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<InterpolationTypes as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_translation(&mut self, x: InterpolationTypes) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[0..].as_mut_ptr(),
                core::mem::size_of::<<InterpolationTypes as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn rotation(&self) -> InterpolationTypes {
        let mut mem =
            core::mem::MaybeUninit::<<InterpolationTypes as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[1..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<InterpolationTypes as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_rotation(&mut self, x: InterpolationTypes) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[1..].as_mut_ptr(),
                core::mem::size_of::<<InterpolationTypes as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn scale(&self) -> InterpolationTypes {
        let mut mem =
            core::mem::MaybeUninit::<<InterpolationTypes as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[2..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<InterpolationTypes as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_scale(&mut self, x: InterpolationTypes) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[2..].as_mut_ptr(),
                core::mem::size_of::<<InterpolationTypes as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn weights(&self) -> InterpolationTypes {
        let mut mem =
            core::mem::MaybeUninit::<<InterpolationTypes as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[3..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<InterpolationTypes as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_weights(&mut self, x: InterpolationTypes) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[3..].as_mut_ptr(),
                core::mem::size_of::<<InterpolationTypes as EndianScalar>::Scalar>(),
            );
        }
    }
}

// struct LayoutType, aligned to 1
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct LayoutType(pub [u8; 3]);
impl Default for LayoutType {
    fn default() -> Self {
        Self([0; 3])
    }
}
impl core::fmt::Debug for LayoutType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LayoutType")
            .field("has_uvs", &self.has_uvs())
            .field("morph_target_count", &self.morph_target_count())
            .field("has_skin", &self.has_skin())
            .finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for LayoutType {}
impl<'a> flatbuffers::Follow<'a> for LayoutType {
    type Inner = &'a LayoutType;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a LayoutType>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a LayoutType {
    type Inner = &'a LayoutType;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<LayoutType>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for LayoutType {
    type Output = LayoutType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(
            self as *const LayoutType as *const u8,
            <Self as flatbuffers::Push>::size(),
        );
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> flatbuffers::PushAlignment {
        flatbuffers::PushAlignment::new(1)
    }
}

impl<'a> flatbuffers::Verifiable for LayoutType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.in_buffer::<Self>(pos)
    }
}

impl<'a> LayoutType {
    #[allow(clippy::too_many_arguments)]
    pub fn new(has_uvs: bool, morph_target_count: u8, has_skin: bool) -> Self {
        let mut s = Self([0; 3]);
        s.set_has_uvs(has_uvs);
        s.set_morph_target_count(morph_target_count);
        s.set_has_skin(has_skin);
        s
    }

    pub fn has_uvs(&self) -> bool {
        let mut mem = core::mem::MaybeUninit::<<bool as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[0..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<bool as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_has_uvs(&mut self, x: bool) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[0..].as_mut_ptr(),
                core::mem::size_of::<<bool as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn morph_target_count(&self) -> u8 {
        let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[1..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_morph_target_count(&mut self, x: u8) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[1..].as_mut_ptr(),
                core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn has_skin(&self) -> bool {
        let mut mem = core::mem::MaybeUninit::<<bool as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[2..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<bool as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_has_skin(&mut self, x: bool) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[2..].as_mut_ptr(),
                core::mem::size_of::<<bool as EndianScalar>::Scalar>(),
            );
        }
    }
}

pub enum PropertyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Property<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Property<'a> {
    type Inner = Property<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Property<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Property { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args PropertyArgs<'args>,
    ) -> flatbuffers::WIPOffset<Property<'bldr>> {
        let mut builder = PropertyBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn name(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Property::VT_NAME, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &Property) -> bool {
        self.name() < o.name()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.name();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Property::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for Property<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct PropertyArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for PropertyArgs<'a> {
    #[inline]
    fn default() -> Self {
        PropertyArgs {
            name: None, // required field
            value: None,
        }
    }
}

pub struct PropertyBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PropertyBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Property::VT_NAME, name);
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Property::VT_VALUE, value);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PropertyBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        PropertyBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Property<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, Property::VT_NAME, "name");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Property<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Property");
        ds.field("name", &self.name());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum ImageNameOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ImageName<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ImageName<'a> {
    type Inner = ImageName<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ImageName<'a> {
    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ImageName { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        _args: &'args ImageNameArgs,
    ) -> flatbuffers::WIPOffset<ImageName<'bldr>> {
        let mut builder = ImageNameBuilder::new(_fbb);
        builder.finish()
    }
}

impl flatbuffers::Verifiable for ImageName<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?.finish();
        Ok(())
    }
}
pub struct ImageNameArgs {}
impl<'a> Default for ImageNameArgs {
    #[inline]
    fn default() -> Self {
        ImageNameArgs {}
    }
}

pub struct ImageNameBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ImageNameBuilder<'a, 'b, A> {
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ImageNameBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ImageNameBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ImageName<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ImageName<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ImageName");
        ds.finish()
    }
}
pub enum RGBAImageDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RGBAImageData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RGBAImageData<'a> {
    type Inner = RGBAImageData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> RGBAImageData<'a> {
    pub const VT_DATA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RGBAImageData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args RGBAImageDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<RGBAImageData<'bldr>> {
        let mut builder = RGBAImageDataBuilder::new(_fbb);
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    RGBAImageData::VT_DATA,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for RGBAImageData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "data",
                Self::VT_DATA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct RGBAImageDataArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for RGBAImageDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        RGBAImageDataArgs { data: None }
    }
}

pub struct RGBAImageDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RGBAImageDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(RGBAImageData::VT_DATA, data);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> RGBAImageDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        RGBAImageDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<RGBAImageData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for RGBAImageData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("RGBAImageData");
        ds.field("data", &self.data());
        ds.finish()
    }
}
pub enum RGBAColorDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RGBAColorData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RGBAColorData<'a> {
    type Inner = RGBAColorData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> RGBAColorData<'a> {
    pub const VT_DATA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RGBAColorData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args RGBAColorDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<RGBAColorData<'bldr>> {
        let mut builder = RGBAColorDataBuilder::new(_fbb);
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn data(&self) -> Option<&'a RGBAColor> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<RGBAColor>(RGBAColorData::VT_DATA, None) }
    }
}

impl flatbuffers::Verifiable for RGBAColorData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<RGBAColor>("data", Self::VT_DATA, false)?
            .finish();
        Ok(())
    }
}
pub struct RGBAColorDataArgs<'a> {
    pub data: Option<&'a RGBAColor>,
}
impl<'a> Default for RGBAColorDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        RGBAColorDataArgs { data: None }
    }
}

pub struct RGBAColorDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RGBAColorDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_data(&mut self, data: &RGBAColor) {
        self.fbb_
            .push_slot_always::<&RGBAColor>(RGBAColorData::VT_DATA, data);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> RGBAColorDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        RGBAColorDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<RGBAColorData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for RGBAColorData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("RGBAColorData");
        ds.field("data", &self.data());
        ds.finish()
    }
}
pub enum ImageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Image<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Image<'a> {
    type Inner = Image<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Image<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_DATA_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_DATA: flatbuffers::VOffsetT = 8;
    pub const VT_WIDTH: flatbuffers::VOffsetT = 10;
    pub const VT_HEIGHT: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Image { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ImageArgs<'args>,
    ) -> flatbuffers::WIPOffset<Image<'bldr>> {
        let mut builder = ImageBuilder::new(_fbb);
        builder.add_height(args.height);
        builder.add_width(args.width);
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_data_type(args.data_type);
        builder.finish()
    }

    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Image::VT_NAME, None)
        }
    }
    #[inline]
    pub fn data_type(&self) -> ImageData {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<ImageData>(Image::VT_DATA_TYPE, Some(ImageData::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn data(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Image::VT_DATA, None)
        }
    }
    #[inline]
    pub fn width(&self) -> u32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<u32>(Image::VT_WIDTH, Some(0)).unwrap() }
    }
    #[inline]
    pub fn height(&self) -> u32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<u32>(Image::VT_HEIGHT, Some(0)).unwrap() }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn data_as_image_name(&self) -> Option<ImageName<'a>> {
        if self.data_type() == ImageData::ImageName {
            self.data().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ImageName::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn data_as_rgba(&self) -> Option<RGBAImageData<'a>> {
        if self.data_type() == ImageData::RGBA {
            self.data().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { RGBAImageData::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn data_as_color(&self) -> Option<RGBAColorData<'a>> {
        if self.data_type() == ImageData::Color {
            self.data().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { RGBAColorData::init_from_table(t) }
            })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for Image<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_union::<ImageData, _>(
                "data_type",
                Self::VT_DATA_TYPE,
                "data",
                Self::VT_DATA,
                false,
                |key, v, pos| match key {
                    ImageData::ImageName => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<ImageName>>(
                            "ImageData::ImageName",
                            pos,
                        ),
                    ImageData::RGBA => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<RGBAImageData>>(
                            "ImageData::RGBA",
                            pos,
                        ),
                    ImageData::Color => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<RGBAColorData>>(
                            "ImageData::Color",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .visit_field::<u32>("width", Self::VT_WIDTH, false)?
            .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
            .finish();
        Ok(())
    }
}
pub struct ImageArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub data_type: ImageData,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub width: u32,
    pub height: u32,
}
impl<'a> Default for ImageArgs<'a> {
    #[inline]
    fn default() -> Self {
        ImageArgs {
            name: None,
            data_type: ImageData::NONE,
            data: None,
            width: 0,
            height: 0,
        }
    }
}

pub struct ImageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ImageBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Image::VT_NAME, name);
    }
    #[inline]
    pub fn add_data_type(&mut self, data_type: ImageData) {
        self.fbb_
            .push_slot::<ImageData>(Image::VT_DATA_TYPE, data_type, ImageData::NONE);
    }
    #[inline]
    pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Image::VT_DATA, data);
    }
    #[inline]
    pub fn add_width(&mut self, width: u32) {
        self.fbb_.push_slot::<u32>(Image::VT_WIDTH, width, 0);
    }
    #[inline]
    pub fn add_height(&mut self, height: u32) {
        self.fbb_.push_slot::<u32>(Image::VT_HEIGHT, height, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ImageBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ImageBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Image<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Image<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Image");
        ds.field("name", &self.name());
        ds.field("data_type", &self.data_type());
        match self.data_type() {
            ImageData::ImageName => {
                if let Some(x) = self.data_as_image_name() {
                    ds.field("data", &x)
                } else {
                    ds.field(
                        "data",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ImageData::RGBA => {
                if let Some(x) = self.data_as_rgba() {
                    ds.field("data", &x)
                } else {
                    ds.field(
                        "data",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ImageData::Color => {
                if let Some(x) = self.data_as_color() {
                    ds.field("data", &x)
                } else {
                    ds.field(
                        "data",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("data", &x)
            }
        };
        ds.field("width", &self.width());
        ds.field("height", &self.height());
        ds.finish()
    }
}
pub enum AnimationValuesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AnimationValues<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AnimationValues<'a> {
    type Inner = AnimationValues<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> AnimationValues<'a> {
    pub const VT_TRANSLATION: flatbuffers::VOffsetT = 4;
    pub const VT_ROTATION: flatbuffers::VOffsetT = 6;
    pub const VT_SCALE: flatbuffers::VOffsetT = 8;
    pub const VT_WEIGHTS: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AnimationValues { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args AnimationValuesArgs<'args>,
    ) -> flatbuffers::WIPOffset<AnimationValues<'bldr>> {
        let mut builder = AnimationValuesBuilder::new(_fbb);
        if let Some(x) = args.weights {
            builder.add_weights(x);
        }
        if let Some(x) = args.scale {
            builder.add_scale(x);
        }
        if let Some(x) = args.rotation {
            builder.add_rotation(x);
        }
        if let Some(x) = args.translation {
            builder.add_translation(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn translation(&self) -> Option<&'a Vector3> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<Vector3>(AnimationValues::VT_TRANSLATION, None)
        }
    }
    #[inline]
    pub fn rotation(&self) -> Option<&'a Vector4> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<Vector4>(AnimationValues::VT_ROTATION, None) }
    }
    #[inline]
    pub fn scale(&self) -> Option<&'a Vector3> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<Vector3>(AnimationValues::VT_SCALE, None) }
    }
    #[inline]
    pub fn weights(&self) -> Option<flatbuffers::Vector<'a, f32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                    AnimationValues::VT_WEIGHTS,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for AnimationValues<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<Vector3>("translation", Self::VT_TRANSLATION, false)?
            .visit_field::<Vector4>("rotation", Self::VT_ROTATION, false)?
            .visit_field::<Vector3>("scale", Self::VT_SCALE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                "weights",
                Self::VT_WEIGHTS,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct AnimationValuesArgs<'a> {
    pub translation: Option<&'a Vector3>,
    pub rotation: Option<&'a Vector4>,
    pub scale: Option<&'a Vector3>,
    pub weights: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
}
impl<'a> Default for AnimationValuesArgs<'a> {
    #[inline]
    fn default() -> Self {
        AnimationValuesArgs {
            translation: None,
            rotation: None,
            scale: None,
            weights: None,
        }
    }
}

pub struct AnimationValuesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AnimationValuesBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_translation(&mut self, translation: &Vector3) {
        self.fbb_
            .push_slot_always::<&Vector3>(AnimationValues::VT_TRANSLATION, translation);
    }
    #[inline]
    pub fn add_rotation(&mut self, rotation: &Vector4) {
        self.fbb_
            .push_slot_always::<&Vector4>(AnimationValues::VT_ROTATION, rotation);
    }
    #[inline]
    pub fn add_scale(&mut self, scale: &Vector3) {
        self.fbb_
            .push_slot_always::<&Vector3>(AnimationValues::VT_SCALE, scale);
    }
    #[inline]
    pub fn add_weights(&mut self, weights: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(AnimationValues::VT_WEIGHTS, weights);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> AnimationValuesBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        AnimationValuesBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<AnimationValues<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for AnimationValues<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("AnimationValues");
        ds.field("translation", &self.translation());
        ds.field("rotation", &self.rotation());
        ds.field("scale", &self.scale());
        ds.field("weights", &self.weights());
        ds.finish()
    }
}
pub enum AnimationKeyFramesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AnimationKeyFrames<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AnimationKeyFrames<'a> {
    type Inner = AnimationKeyFrames<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> AnimationKeyFrames<'a> {
    pub const VT_TIME: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AnimationKeyFrames { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args AnimationKeyFramesArgs<'args>,
    ) -> flatbuffers::WIPOffset<AnimationKeyFrames<'bldr>> {
        let mut builder = AnimationKeyFramesBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_time(args.time);
        builder.finish()
    }

    #[inline]
    pub fn time(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(AnimationKeyFrames::VT_TIME, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn value(&self) -> Option<AnimationValues<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<AnimationValues>>(
                    AnimationKeyFrames::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for AnimationKeyFrames<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("time", Self::VT_TIME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<AnimationValues>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct AnimationKeyFramesArgs<'a> {
    pub time: f32,
    pub value: Option<flatbuffers::WIPOffset<AnimationValues<'a>>>,
}
impl<'a> Default for AnimationKeyFramesArgs<'a> {
    #[inline]
    fn default() -> Self {
        AnimationKeyFramesArgs {
            time: 0.0,
            value: None,
        }
    }
}

pub struct AnimationKeyFramesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AnimationKeyFramesBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_time(&mut self, time: f32) {
        self.fbb_
            .push_slot::<f32>(AnimationKeyFrames::VT_TIME, time, 0.0);
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<AnimationValues<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<AnimationValues>>(
                AnimationKeyFrames::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> AnimationKeyFramesBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        AnimationKeyFramesBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<AnimationKeyFrames<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for AnimationKeyFrames<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("AnimationKeyFrames");
        ds.field("time", &self.time());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum AnimationSetOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AnimationSet<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AnimationSet<'a> {
    type Inner = AnimationSet<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> AnimationSet<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_ANIMATIONS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AnimationSet { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args AnimationSetArgs<'args>,
    ) -> flatbuffers::WIPOffset<AnimationSet<'bldr>> {
        let mut builder = AnimationSetBuilder::new(_fbb);
        if let Some(x) = args.animations {
            builder.add_animations(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn name(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(AnimationSet::VT_NAME, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &AnimationSet) -> bool {
        self.name() < o.name()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.name();
        key.cmp(val)
    }
    #[inline]
    pub fn animations(&self) -> Option<Animation<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Animation>>(AnimationSet::VT_ANIMATIONS, None)
        }
    }
}

impl flatbuffers::Verifiable for AnimationSet<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<Animation>>(
                "animations",
                Self::VT_ANIMATIONS,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct AnimationSetArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub animations: Option<flatbuffers::WIPOffset<Animation<'a>>>,
}
impl<'a> Default for AnimationSetArgs<'a> {
    #[inline]
    fn default() -> Self {
        AnimationSetArgs {
            name: None, // required field
            animations: None,
        }
    }
}

pub struct AnimationSetBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AnimationSetBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(AnimationSet::VT_NAME, name);
    }
    #[inline]
    pub fn add_animations(&mut self, animations: flatbuffers::WIPOffset<Animation<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<Animation>>(
                AnimationSet::VT_ANIMATIONS,
                animations,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> AnimationSetBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        AnimationSetBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<AnimationSet<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, AnimationSet::VT_NAME, "name");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for AnimationSet<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("AnimationSet");
        ds.field("name", &self.name());
        ds.field("animations", &self.animations());
        ds.finish()
    }
}
pub enum AnimationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Animation<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Animation<'a> {
    type Inner = Animation<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Animation<'a> {
    pub const VT_TARGET: flatbuffers::VOffsetT = 4;
    pub const VT_TARGET_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_INTERPOLATION: flatbuffers::VOffsetT = 8;
    pub const VT_FRAMES: flatbuffers::VOffsetT = 10;
    pub const VT_DURATION: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Animation { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args AnimationArgs<'args>,
    ) -> flatbuffers::WIPOffset<Animation<'bldr>> {
        let mut builder = AnimationBuilder::new(_fbb);
        builder.add_target(args.target);
        builder.add_duration(args.duration);
        if let Some(x) = args.frames {
            builder.add_frames(x);
        }
        if let Some(x) = args.interpolation {
            builder.add_interpolation(x);
        }
        builder.add_target_type(args.target_type);
        builder.finish()
    }

    #[inline]
    pub fn target(&self) -> u64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<u64>(Animation::VT_TARGET, Some(0)).unwrap() }
    }
    #[inline]
    pub fn target_type(&self) -> AnimationTargetTypes {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<AnimationTargetTypes>(
                    Animation::VT_TARGET_TYPE,
                    Some(AnimationTargetTypes::Object),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn interpolation(&self) -> Option<&'a InterpolationTargets> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<InterpolationTargets>(Animation::VT_INTERPOLATION, None)
        }
    }
    #[inline]
    pub fn frames(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationKeyFrames<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationKeyFrames>>,
            >>(Animation::VT_FRAMES, None)
        }
    }
    #[inline]
    pub fn duration(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(Animation::VT_DURATION, Some(0.0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for Animation<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<u64>("target", Self::VT_TARGET, false)?
            .visit_field::<AnimationTargetTypes>("target_type", Self::VT_TARGET_TYPE, false)?
            .visit_field::<InterpolationTargets>("interpolation", Self::VT_INTERPOLATION, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AnimationKeyFrames>>,
            >>("frames", Self::VT_FRAMES, false)?
            .visit_field::<f32>("duration", Self::VT_DURATION, false)?
            .finish();
        Ok(())
    }
}
pub struct AnimationArgs<'a> {
    pub target: u64,
    pub target_type: AnimationTargetTypes,
    pub interpolation: Option<&'a InterpolationTargets>,
    pub frames: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationKeyFrames<'a>>>,
        >,
    >,
    pub duration: f32,
}
impl<'a> Default for AnimationArgs<'a> {
    #[inline]
    fn default() -> Self {
        AnimationArgs {
            target: 0,
            target_type: AnimationTargetTypes::Object,
            interpolation: None,
            frames: None,
            duration: 0.0,
        }
    }
}

pub struct AnimationBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AnimationBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_target(&mut self, target: u64) {
        self.fbb_.push_slot::<u64>(Animation::VT_TARGET, target, 0);
    }
    #[inline]
    pub fn add_target_type(&mut self, target_type: AnimationTargetTypes) {
        self.fbb_.push_slot::<AnimationTargetTypes>(
            Animation::VT_TARGET_TYPE,
            target_type,
            AnimationTargetTypes::Object,
        );
    }
    #[inline]
    pub fn add_interpolation(&mut self, interpolation: &InterpolationTargets) {
        self.fbb_
            .push_slot_always::<&InterpolationTargets>(Animation::VT_INTERPOLATION, interpolation);
    }
    #[inline]
    pub fn add_frames(
        &mut self,
        frames: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<AnimationKeyFrames<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Animation::VT_FRAMES, frames);
    }
    #[inline]
    pub fn add_duration(&mut self, duration: f32) {
        self.fbb_
            .push_slot::<f32>(Animation::VT_DURATION, duration, 0.0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AnimationBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        AnimationBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Animation<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Animation<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Animation");
        ds.field("target", &self.target());
        ds.field("target_type", &self.target_type());
        ds.field("interpolation", &self.interpolation());
        ds.field("frames", &self.frames());
        ds.field("duration", &self.duration());
        ds.finish()
    }
}
pub enum MorphTargetsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MorphTargets<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MorphTargets<'a> {
    type Inner = MorphTargets<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> MorphTargets<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_TRANSLATION: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MorphTargets { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args MorphTargetsArgs<'args>,
    ) -> flatbuffers::WIPOffset<MorphTargets<'bldr>> {
        let mut builder = MorphTargetsBuilder::new(_fbb);
        if let Some(x) = args.translation {
            builder.add_translation(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn name(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(MorphTargets::VT_NAME, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn translation(&self) -> Option<flatbuffers::Vector<'a, Vector3>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Vector3>>>(
                    MorphTargets::VT_TRANSLATION,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for MorphTargets<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Vector3>>>(
                "translation",
                Self::VT_TRANSLATION,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct MorphTargetsArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub translation: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Vector3>>>,
}
impl<'a> Default for MorphTargetsArgs<'a> {
    #[inline]
    fn default() -> Self {
        MorphTargetsArgs {
            name: None, // required field
            translation: None,
        }
    }
}

pub struct MorphTargetsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MorphTargetsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(MorphTargets::VT_NAME, name);
    }
    #[inline]
    pub fn add_translation(
        &mut self,
        translation: flatbuffers::WIPOffset<flatbuffers::Vector<'b, Vector3>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            MorphTargets::VT_TRANSLATION,
            translation,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> MorphTargetsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        MorphTargetsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<MorphTargets<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, MorphTargets::VT_NAME, "name");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for MorphTargets<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("MorphTargets");
        ds.field("name", &self.name());
        ds.field("translation", &self.translation());
        ds.finish()
    }
}
pub enum SkeletonOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Skeleton<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Skeleton<'a> {
    type Inner = Skeleton<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Skeleton<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_ROOT_INDEX: flatbuffers::VOffsetT = 8;
    pub const VT_INVERSE_BIND_MATRIXES: flatbuffers::VOffsetT = 10;
    pub const VT_BONES: flatbuffers::VOffsetT = 12;
    pub const VT_PROPERTIES: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Skeleton { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args SkeletonArgs<'args>,
    ) -> flatbuffers::WIPOffset<Skeleton<'bldr>> {
        let mut builder = SkeletonBuilder::new(_fbb);
        builder.add_id(args.id);
        if let Some(x) = args.properties {
            builder.add_properties(x);
        }
        if let Some(x) = args.bones {
            builder.add_bones(x);
        }
        if let Some(x) = args.inverse_bind_matrixes {
            builder.add_inverse_bind_matrixes(x);
        }
        if let Some(x) = args.root_index {
            builder.add_root_index(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    /// The internal index from the json file
    #[inline]
    pub fn id(&self) -> u64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<u64>(Skeleton::VT_ID, Some(0)).unwrap() }
    }
    /// User-provided name
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Skeleton::VT_NAME, None)
        }
    }
    /// The root of the skeleton tree
    #[inline]
    pub fn root_index(&self) -> Option<&'a GlobalNodeIdentifier> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<GlobalNodeIdentifier>(Skeleton::VT_ROOT_INDEX, None)
        }
    }
    /// Matrixes used to bring coordinates being skinned into the same space as the joint
    #[inline]
    pub fn inverse_bind_matrixes(&self) -> Option<flatbuffers::Vector<'a, Matrix4>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Matrix4>>>(
                    Skeleton::VT_INVERSE_BIND_MATRIXES,
                    None,
                )
        }
    }
    /// List of bones assoicated with the skeleton
    #[inline]
    pub fn bones(&self) -> Option<flatbuffers::Vector<'a, GlobalNodeIdentifier>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, GlobalNodeIdentifier>>>(
                    Skeleton::VT_BONES,
                    None,
                )
        }
    }
    /// Extra user data
    #[inline]
    pub fn properties(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property>>,
            >>(Skeleton::VT_PROPERTIES, None)
        }
    }
}

impl flatbuffers::Verifiable for Skeleton<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<u64>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<GlobalNodeIdentifier>("root_index", Self::VT_ROOT_INDEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Matrix4>>>("inverse_bind_matrixes", Self::VT_INVERSE_BIND_MATRIXES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, GlobalNodeIdentifier>>>("bones", Self::VT_BONES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Property>>>>("properties", Self::VT_PROPERTIES, false)?
     .finish();
        Ok(())
    }
}
pub struct SkeletonArgs<'a> {
    pub id: u64,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub root_index: Option<&'a GlobalNodeIdentifier>,
    pub inverse_bind_matrixes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Matrix4>>>,
    pub bones: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, GlobalNodeIdentifier>>>,
    pub properties: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>>,
    >,
}
impl<'a> Default for SkeletonArgs<'a> {
    #[inline]
    fn default() -> Self {
        SkeletonArgs {
            id: 0,
            name: None,
            root_index: None,
            inverse_bind_matrixes: None,
            bones: None,
            properties: None,
        }
    }
}

pub struct SkeletonBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SkeletonBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: u64) {
        self.fbb_.push_slot::<u64>(Skeleton::VT_ID, id, 0);
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Skeleton::VT_NAME, name);
    }
    #[inline]
    pub fn add_root_index(&mut self, root_index: &GlobalNodeIdentifier) {
        self.fbb_
            .push_slot_always::<&GlobalNodeIdentifier>(Skeleton::VT_ROOT_INDEX, root_index);
    }
    #[inline]
    pub fn add_inverse_bind_matrixes(
        &mut self,
        inverse_bind_matrixes: flatbuffers::WIPOffset<flatbuffers::Vector<'b, Matrix4>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            Skeleton::VT_INVERSE_BIND_MATRIXES,
            inverse_bind_matrixes,
        );
    }
    #[inline]
    pub fn add_bones(
        &mut self,
        bones: flatbuffers::WIPOffset<flatbuffers::Vector<'b, GlobalNodeIdentifier>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Skeleton::VT_BONES, bones);
    }
    #[inline]
    pub fn add_properties(
        &mut self,
        properties: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Property<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Skeleton::VT_PROPERTIES, properties);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SkeletonBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        SkeletonBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Skeleton<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Skeleton<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Skeleton");
        ds.field("id", &self.id());
        ds.field("name", &self.name());
        ds.field("root_index", &self.root_index());
        ds.field("inverse_bind_matrixes", &self.inverse_bind_matrixes());
        ds.field("bones", &self.bones());
        ds.field("properties", &self.properties());
        ds.finish()
    }
}
pub enum MeshOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Mesh<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Mesh<'a> {
    type Inner = Mesh<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Mesh<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_ID: flatbuffers::VOffsetT = 6;
    pub const VT_TRANSFORM: flatbuffers::VOffsetT = 8;
    pub const VT_POINTS: flatbuffers::VOffsetT = 10;
    pub const VT_MORPH_TARGETS: flatbuffers::VOffsetT = 12;
    pub const VT_DEFAULT_MORPH_WEIGHTS: flatbuffers::VOffsetT = 14;
    pub const VT_TRIANGLES: flatbuffers::VOffsetT = 16;
    pub const VT_ANIMATIONS: flatbuffers::VOffsetT = 18;
    pub const VT_UVS: flatbuffers::VOffsetT = 20;
    pub const VT_SKELETON: flatbuffers::VOffsetT = 22;
    pub const VT_TEXTURE: flatbuffers::VOffsetT = 24;
    pub const VT_LAYOUT_TYPE: flatbuffers::VOffsetT = 26;
    pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 28;
    pub const VT_PROPERTIES: flatbuffers::VOffsetT = 30;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Mesh { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args MeshArgs<'args>,
    ) -> flatbuffers::WIPOffset<Mesh<'bldr>> {
        let mut builder = MeshBuilder::new(_fbb);
        builder.add_id(args.id);
        if let Some(x) = args.properties {
            builder.add_properties(x);
        }
        if let Some(x) = args.attributes {
            builder.add_attributes(x);
        }
        if let Some(x) = args.layout_type {
            builder.add_layout_type(x);
        }
        if let Some(x) = args.texture {
            builder.add_texture(x);
        }
        if let Some(x) = args.skeleton {
            builder.add_skeleton(x);
        }
        if let Some(x) = args.uvs {
            builder.add_uvs(x);
        }
        if let Some(x) = args.animations {
            builder.add_animations(x);
        }
        if let Some(x) = args.triangles {
            builder.add_triangles(x);
        }
        if let Some(x) = args.default_morph_weights {
            builder.add_default_morph_weights(x);
        }
        if let Some(x) = args.morph_targets {
            builder.add_morph_targets(x);
        }
        if let Some(x) = args.points {
            builder.add_points(x);
        }
        if let Some(x) = args.transform {
            builder.add_transform(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn name(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Mesh::VT_NAME, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn id(&self) -> u64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<u64>(Mesh::VT_ID, Some(0)).unwrap() }
    }
    #[inline]
    pub fn transform(&self) -> &'a Transform {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<Transform>(Mesh::VT_TRANSFORM, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn points(&self) -> flatbuffers::Vector<'a, f32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                    Mesh::VT_POINTS,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn morph_targets(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MorphTargets<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MorphTargets>>,
            >>(Mesh::VT_MORPH_TARGETS, None)
        }
    }
    #[inline]
    pub fn default_morph_weights(&self) -> Option<flatbuffers::Vector<'a, f32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                    Mesh::VT_DEFAULT_MORPH_WEIGHTS,
                    None,
                )
        }
    }
    #[inline]
    pub fn triangles(&self) -> flatbuffers::Vector<'a, u32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    Mesh::VT_TRIANGLES,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn animations(
        &self,
    ) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationSet<'a>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationSet>>,
                >>(Mesh::VT_ANIMATIONS, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn uvs(&self) -> Option<flatbuffers::Vector<'a, f32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                    Mesh::VT_UVS,
                    None,
                )
        }
    }
    #[inline]
    pub fn skeleton(&self) -> Option<Skeleton<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Skeleton>>(Mesh::VT_SKELETON, None)
        }
    }
    #[inline]
    pub fn texture(&self) -> Option<Image<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Image>>(Mesh::VT_TEXTURE, None)
        }
    }
    #[inline]
    pub fn layout_type(&self) -> &'a LayoutType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<LayoutType>(Mesh::VT_LAYOUT_TYPE, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn attributes(&self) -> flatbuffers::Vector<'a, f32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                    Mesh::VT_ATTRIBUTES,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn properties(
        &self,
    ) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property>>,
                >>(Mesh::VT_PROPERTIES, None)
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for Mesh<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
            .visit_field::<u64>("id", Self::VT_ID, false)?
            .visit_field::<Transform>("transform", Self::VT_TRANSFORM, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                "points",
                Self::VT_POINTS,
                true,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MorphTargets>>,
            >>("morph_targets", Self::VT_MORPH_TARGETS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                "default_morph_weights",
                Self::VT_DEFAULT_MORPH_WEIGHTS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "triangles",
                Self::VT_TRIANGLES,
                true,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AnimationSet>>,
            >>("animations", Self::VT_ANIMATIONS, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                "uvs",
                Self::VT_UVS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<Skeleton>>(
                "skeleton",
                Self::VT_SKELETON,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<Image>>("texture", Self::VT_TEXTURE, false)?
            .visit_field::<LayoutType>("layout_type", Self::VT_LAYOUT_TYPE, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                "attributes",
                Self::VT_ATTRIBUTES,
                true,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Property>>,
            >>("properties", Self::VT_PROPERTIES, true)?
            .finish();
        Ok(())
    }
}
pub struct MeshArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub id: u64,
    pub transform: Option<&'a Transform>,
    pub points: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub morph_targets: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MorphTargets<'a>>>,
        >,
    >,
    pub default_morph_weights: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub triangles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub animations: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationSet<'a>>>,
        >,
    >,
    pub uvs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub skeleton: Option<flatbuffers::WIPOffset<Skeleton<'a>>>,
    pub texture: Option<flatbuffers::WIPOffset<Image<'a>>>,
    pub layout_type: Option<&'a LayoutType>,
    pub attributes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub properties: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>>,
    >,
}
impl<'a> Default for MeshArgs<'a> {
    #[inline]
    fn default() -> Self {
        MeshArgs {
            name: None, // required field
            id: 0,
            transform: None, // required field
            points: None,    // required field
            morph_targets: None,
            default_morph_weights: None,
            triangles: None,  // required field
            animations: None, // required field
            uvs: None,
            skeleton: None,
            texture: None,
            layout_type: None, // required field
            attributes: None,  // required field
            properties: None,  // required field
        }
    }
}

pub struct MeshBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MeshBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Mesh::VT_NAME, name);
    }
    #[inline]
    pub fn add_id(&mut self, id: u64) {
        self.fbb_.push_slot::<u64>(Mesh::VT_ID, id, 0);
    }
    #[inline]
    pub fn add_transform(&mut self, transform: &Transform) {
        self.fbb_
            .push_slot_always::<&Transform>(Mesh::VT_TRANSFORM, transform);
    }
    #[inline]
    pub fn add_points(&mut self, points: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Mesh::VT_POINTS, points);
    }
    #[inline]
    pub fn add_morph_targets(
        &mut self,
        morph_targets: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<MorphTargets<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Mesh::VT_MORPH_TARGETS, morph_targets);
    }
    #[inline]
    pub fn add_default_morph_weights(
        &mut self,
        default_morph_weights: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            Mesh::VT_DEFAULT_MORPH_WEIGHTS,
            default_morph_weights,
        );
    }
    #[inline]
    pub fn add_triangles(
        &mut self,
        triangles: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Mesh::VT_TRIANGLES, triangles);
    }
    #[inline]
    pub fn add_animations(
        &mut self,
        animations: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<AnimationSet<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Mesh::VT_ANIMATIONS, animations);
    }
    #[inline]
    pub fn add_uvs(&mut self, uvs: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Mesh::VT_UVS, uvs);
    }
    #[inline]
    pub fn add_skeleton(&mut self, skeleton: flatbuffers::WIPOffset<Skeleton<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<Skeleton>>(Mesh::VT_SKELETON, skeleton);
    }
    #[inline]
    pub fn add_texture(&mut self, texture: flatbuffers::WIPOffset<Image<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<Image>>(Mesh::VT_TEXTURE, texture);
    }
    #[inline]
    pub fn add_layout_type(&mut self, layout_type: &LayoutType) {
        self.fbb_
            .push_slot_always::<&LayoutType>(Mesh::VT_LAYOUT_TYPE, layout_type);
    }
    #[inline]
    pub fn add_attributes(
        &mut self,
        attributes: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Mesh::VT_ATTRIBUTES, attributes);
    }
    #[inline]
    pub fn add_properties(
        &mut self,
        properties: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Property<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Mesh::VT_PROPERTIES, properties);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MeshBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        MeshBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Mesh<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, Mesh::VT_NAME, "name");
        self.fbb_.required(o, Mesh::VT_TRANSFORM, "transform");
        self.fbb_.required(o, Mesh::VT_POINTS, "points");
        self.fbb_.required(o, Mesh::VT_TRIANGLES, "triangles");
        self.fbb_.required(o, Mesh::VT_ANIMATIONS, "animations");
        self.fbb_.required(o, Mesh::VT_LAYOUT_TYPE, "layout_type");
        self.fbb_.required(o, Mesh::VT_ATTRIBUTES, "attributes");
        self.fbb_.required(o, Mesh::VT_PROPERTIES, "properties");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Mesh<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Mesh");
        ds.field("name", &self.name());
        ds.field("id", &self.id());
        ds.field("transform", &self.transform());
        ds.field("points", &self.points());
        ds.field("morph_targets", &self.morph_targets());
        ds.field("default_morph_weights", &self.default_morph_weights());
        ds.field("triangles", &self.triangles());
        ds.field("animations", &self.animations());
        ds.field("uvs", &self.uvs());
        ds.field("skeleton", &self.skeleton());
        ds.field("texture", &self.texture());
        ds.field("layout_type", &self.layout_type());
        ds.field("attributes", &self.attributes());
        ds.field("properties", &self.properties());
        ds.finish()
    }
}
pub enum EmptiesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Empties<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Empties<'a> {
    type Inner = Empties<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Empties<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_TRANSFORM: flatbuffers::VOffsetT = 8;
    pub const VT_ANIMATIONS: flatbuffers::VOffsetT = 10;
    pub const VT_PROPERTIES: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Empties { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args EmptiesArgs<'args>,
    ) -> flatbuffers::WIPOffset<Empties<'bldr>> {
        let mut builder = EmptiesBuilder::new(_fbb);
        builder.add_id(args.id);
        if let Some(x) = args.properties {
            builder.add_properties(x);
        }
        if let Some(x) = args.animations {
            builder.add_animations(x);
        }
        if let Some(x) = args.transform {
            builder.add_transform(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> u64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<u64>(Empties::VT_ID, Some(0)).unwrap() }
    }
    #[inline]
    pub fn name(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Empties::VT_NAME, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn transform(&self) -> &'a Transform {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<Transform>(Empties::VT_TRANSFORM, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn animations(
        &self,
    ) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationSet<'a>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationSet>>,
                >>(Empties::VT_ANIMATIONS, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn properties(
        &self,
    ) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property>>,
                >>(Empties::VT_PROPERTIES, None)
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for Empties<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<u64>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
            .visit_field::<Transform>("transform", Self::VT_TRANSFORM, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AnimationSet>>,
            >>("animations", Self::VT_ANIMATIONS, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Property>>,
            >>("properties", Self::VT_PROPERTIES, true)?
            .finish();
        Ok(())
    }
}
pub struct EmptiesArgs<'a> {
    pub id: u64,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub transform: Option<&'a Transform>,
    pub animations: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimationSet<'a>>>,
        >,
    >,
    pub properties: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>>,
    >,
}
impl<'a> Default for EmptiesArgs<'a> {
    #[inline]
    fn default() -> Self {
        EmptiesArgs {
            id: 0,
            name: None,       // required field
            transform: None,  // required field
            animations: None, // required field
            properties: None, // required field
        }
    }
}

pub struct EmptiesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EmptiesBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: u64) {
        self.fbb_.push_slot::<u64>(Empties::VT_ID, id, 0);
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Empties::VT_NAME, name);
    }
    #[inline]
    pub fn add_transform(&mut self, transform: &Transform) {
        self.fbb_
            .push_slot_always::<&Transform>(Empties::VT_TRANSFORM, transform);
    }
    #[inline]
    pub fn add_animations(
        &mut self,
        animations: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<AnimationSet<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Empties::VT_ANIMATIONS, animations);
    }
    #[inline]
    pub fn add_properties(
        &mut self,
        properties: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Property<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Empties::VT_PROPERTIES, properties);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EmptiesBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        EmptiesBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Empties<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, Empties::VT_NAME, "name");
        self.fbb_.required(o, Empties::VT_TRANSFORM, "transform");
        self.fbb_.required(o, Empties::VT_ANIMATIONS, "animations");
        self.fbb_.required(o, Empties::VT_PROPERTIES, "properties");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Empties<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Empties");
        ds.field("id", &self.id());
        ds.field("name", &self.name());
        ds.field("transform", &self.transform());
        ds.field("animations", &self.animations());
        ds.field("properties", &self.properties());
        ds.finish()
    }
}
pub enum NodeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Node<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Node<'a> {
    type Inner = Node<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Node<'a> {
    pub const VT_CHILDREN: flatbuffers::VOffsetT = 4;
    pub const VT_OBJECT_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_OBJECT: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Node { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args NodeArgs<'args>,
    ) -> flatbuffers::WIPOffset<Node<'bldr>> {
        let mut builder = NodeBuilder::new(_fbb);
        if let Some(x) = args.object {
            builder.add_object(x);
        }
        if let Some(x) = args.children {
            builder.add_children(x);
        }
        builder.add_object_type(args.object_type);
        builder.finish()
    }

    #[inline]
    pub fn children(&self) -> flatbuffers::Vector<'a, u32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    Node::VT_CHILDREN,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn object_type(&self) -> Object {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<Object>(Node::VT_OBJECT_TYPE, Some(Object::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn object(&self) -> flatbuffers::Table<'a> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Node::VT_OBJECT, None)
                .unwrap()
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn object_as_mesh(&self) -> Option<Mesh<'a>> {
        if self.object_type() == Object::Mesh {
            let u = self.object();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid union in this slot
            Some(unsafe { Mesh::init_from_table(u) })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn object_as_empties(&self) -> Option<Empties<'a>> {
        if self.object_type() == Object::Empties {
            let u = self.object();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid union in this slot
            Some(unsafe { Empties::init_from_table(u) })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for Node<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "children",
                Self::VT_CHILDREN,
                true,
            )?
            .visit_union::<Object, _>(
                "object_type",
                Self::VT_OBJECT_TYPE,
                "object",
                Self::VT_OBJECT,
                true,
                |key, v, pos| match key {
                    Object::Mesh => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Mesh>>(
                        "Object::Mesh",
                        pos,
                    ),
                    Object::Empties => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<Empties>>(
                            "Object::Empties",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .finish();
        Ok(())
    }
}
pub struct NodeArgs<'a> {
    pub children: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub object_type: Object,
    pub object: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for NodeArgs<'a> {
    #[inline]
    fn default() -> Self {
        NodeArgs {
            children: None, // required field
            object_type: Object::NONE,
            object: None, // required field
        }
    }
}

pub struct NodeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NodeBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_children(&mut self, children: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Node::VT_CHILDREN, children);
    }
    #[inline]
    pub fn add_object_type(&mut self, object_type: Object) {
        self.fbb_
            .push_slot::<Object>(Node::VT_OBJECT_TYPE, object_type, Object::NONE);
    }
    #[inline]
    pub fn add_object(&mut self, object: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Node::VT_OBJECT, object);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> NodeBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        NodeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Node<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, Node::VT_CHILDREN, "children");
        self.fbb_.required(o, Node::VT_OBJECT, "object");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Node<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Node");
        ds.field("children", &self.children());
        ds.field("object_type", &self.object_type());
        match self.object_type() {
            Object::Mesh => {
                if let Some(x) = self.object_as_mesh() {
                    ds.field("object", &x)
                } else {
                    ds.field(
                        "object",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            Object::Empties => {
                if let Some(x) = self.object_as_empties() {
                    ds.field("object", &x)
                } else {
                    ds.field(
                        "object",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("object", &x)
            }
        };
        ds.finish()
    }
}
pub enum GltfSceneOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GltfScene<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GltfScene<'a> {
    type Inner = GltfScene<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> GltfScene<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_OBJECTS: flatbuffers::VOffsetT = 6;
    pub const VT_ROOT_NODES: flatbuffers::VOffsetT = 8;
    pub const VT_MODEL_INDEX: flatbuffers::VOffsetT = 10;
    pub const VT_EMPTY_INDEX: flatbuffers::VOffsetT = 12;
    pub const VT_PROPERTIES: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GltfScene { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args GltfSceneArgs<'args>,
    ) -> flatbuffers::WIPOffset<GltfScene<'bldr>> {
        let mut builder = GltfSceneBuilder::new(_fbb);
        if let Some(x) = args.properties {
            builder.add_properties(x);
        }
        if let Some(x) = args.empty_index {
            builder.add_empty_index(x);
        }
        if let Some(x) = args.model_index {
            builder.add_model_index(x);
        }
        if let Some(x) = args.root_nodes {
            builder.add_root_nodes(x);
        }
        if let Some(x) = args.objects {
            builder.add_objects(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn name(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(GltfScene::VT_NAME, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn objects(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Node<'a>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Node>>,
                >>(GltfScene::VT_OBJECTS, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn root_nodes(&self) -> flatbuffers::Vector<'a, u32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    GltfScene::VT_ROOT_NODES,
                    None,
                )
                .unwrap()
        }
    }
    /// These are indexes into the object array
    #[inline]
    pub fn model_index(&self) -> flatbuffers::Vector<'a, u32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    GltfScene::VT_MODEL_INDEX,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn empty_index(&self) -> flatbuffers::Vector<'a, u32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    GltfScene::VT_EMPTY_INDEX,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn properties(
        &self,
    ) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property>>,
                >>(GltfScene::VT_PROPERTIES, None)
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for GltfScene<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Node>>,
            >>("objects", Self::VT_OBJECTS, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "root_nodes",
                Self::VT_ROOT_NODES,
                true,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "model_index",
                Self::VT_MODEL_INDEX,
                true,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "empty_index",
                Self::VT_EMPTY_INDEX,
                true,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Property>>,
            >>("properties", Self::VT_PROPERTIES, true)?
            .finish();
        Ok(())
    }
}
pub struct GltfSceneArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub objects: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Node<'a>>>>,
    >,
    pub root_nodes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub model_index: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub empty_index: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub properties: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>>,
    >,
}
impl<'a> Default for GltfSceneArgs<'a> {
    #[inline]
    fn default() -> Self {
        GltfSceneArgs {
            name: None,        // required field
            objects: None,     // required field
            root_nodes: None,  // required field
            model_index: None, // required field
            empty_index: None, // required field
            properties: None,  // required field
        }
    }
}

pub struct GltfSceneBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GltfSceneBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(GltfScene::VT_NAME, name);
    }
    #[inline]
    pub fn add_objects(
        &mut self,
        objects: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Node<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(GltfScene::VT_OBJECTS, objects);
    }
    #[inline]
    pub fn add_root_nodes(
        &mut self,
        root_nodes: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(GltfScene::VT_ROOT_NODES, root_nodes);
    }
    #[inline]
    pub fn add_model_index(
        &mut self,
        model_index: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(GltfScene::VT_MODEL_INDEX, model_index);
    }
    #[inline]
    pub fn add_empty_index(
        &mut self,
        empty_index: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(GltfScene::VT_EMPTY_INDEX, empty_index);
    }
    #[inline]
    pub fn add_properties(
        &mut self,
        properties: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Property<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(GltfScene::VT_PROPERTIES, properties);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GltfSceneBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        GltfSceneBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<GltfScene<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, GltfScene::VT_NAME, "name");
        self.fbb_.required(o, GltfScene::VT_OBJECTS, "objects");
        self.fbb_
            .required(o, GltfScene::VT_ROOT_NODES, "root_nodes");
        self.fbb_
            .required(o, GltfScene::VT_MODEL_INDEX, "model_index");
        self.fbb_
            .required(o, GltfScene::VT_EMPTY_INDEX, "empty_index");
        self.fbb_
            .required(o, GltfScene::VT_PROPERTIES, "properties");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for GltfScene<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("GltfScene");
        ds.field("name", &self.name());
        ds.field("objects", &self.objects());
        ds.field("root_nodes", &self.root_nodes());
        ds.field("model_index", &self.model_index());
        ds.field("empty_index", &self.empty_index());
        ds.field("properties", &self.properties());
        ds.finish()
    }
}
pub enum ScenesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Scenes<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Scenes<'a> {
    type Inner = Scenes<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Scenes<'a> {
    pub const VT_SCENES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Scenes { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ScenesArgs<'args>,
    ) -> flatbuffers::WIPOffset<Scenes<'bldr>> {
        let mut builder = ScenesBuilder::new(_fbb);
        if let Some(x) = args.scenes {
            builder.add_scenes(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn scenes(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GltfScene<'a>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GltfScene>>,
                >>(Scenes::VT_SCENES, None)
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for Scenes<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GltfScene>>,
            >>("scenes", Self::VT_SCENES, true)?
            .finish();
        Ok(())
    }
}
pub struct ScenesArgs<'a> {
    pub scenes: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GltfScene<'a>>>,
        >,
    >,
}
impl<'a> Default for ScenesArgs<'a> {
    #[inline]
    fn default() -> Self {
        ScenesArgs {
            scenes: None, // required field
        }
    }
}

pub struct ScenesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ScenesBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_scenes(
        &mut self,
        scenes: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<GltfScene<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Scenes::VT_SCENES, scenes);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ScenesBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ScenesBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Scenes<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, Scenes::VT_SCENES, "scenes");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Scenes<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Scenes");
        ds.field("scenes", &self.scenes());
        ds.finish()
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Scenes`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_scenes_unchecked`.
pub fn root_as_scenes(buf: &[u8]) -> Result<Scenes, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<Scenes>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Scenes` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_scenes_unchecked`.
pub fn size_prefixed_root_as_scenes(buf: &[u8]) -> Result<Scenes, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<Scenes>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Scenes` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_scenes_unchecked`.
pub fn root_as_scenes_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<Scenes<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<Scenes<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Scenes` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_scenes_unchecked`.
pub fn size_prefixed_root_as_scenes_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<Scenes<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<Scenes<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Scenes and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Scenes`.
pub unsafe fn root_as_scenes_unchecked(buf: &[u8]) -> Scenes {
    flatbuffers::root_unchecked::<Scenes>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Scenes and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Scenes`.
pub unsafe fn size_prefixed_root_as_scenes_unchecked(buf: &[u8]) -> Scenes {
    flatbuffers::size_prefixed_root_unchecked::<Scenes>(buf)
}
#[inline]
pub fn finish_scenes_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Scenes<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_scenes_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Scenes<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
